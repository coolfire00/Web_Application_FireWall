/* 
**  mod_pwd_waf.c -- Apache sample pwd_waf module
**  [Autogenerated via ``apxs -n pwd_waf -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_pwd_waf.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /pwd_waf in as follows:
**
**    #   apache2.conf
**    LoadModule pwd_waf_module modules/mod_pwd_waf.so
**    <Location /pwd_waf>
**    SetHandler pwd_waf
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /pwd_waf and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/pwd_waf 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_pwd_waf.c
*/ 

#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "http_core.h"
#include "http_request.h"

#include "ap_config.h"
#include "apr_strings.h"
#include "apr_network_io.h"
#include <apr_file_info.h>
#include <apr_file_io.h>
#include <apr_tables.h>
#include "util_script.h"

#include "mod_pwd_waf.h"

/* Web Application Firewall by Team Password */
static int pwd_waf_handler(request_rec *r)
{
    
    if(strcmp(r->uri,"/fw/tt.php")==0)	{
      	// Get
      	ap_rputs("<H2>", r);
      	if(checkGETParms(r, NULL, 0)==ILLEGAL){
			// TODO
			return DONE;
		}
		ap_rputs("</H2>", r);
		// End of Get
        return OK;
	}
	
	
	if(strcmp(r->uri,"/fw/form.php")==0){
		ap_rputs("<H2>", r);
		if(checkPOSTParms(r, NULL, 0)==ILLEGAL){
			// TODO
			return DONE;
		}
	    ap_rputs("</H2>", r);
		return OK;
	}
	
	if(strcmp(r->uri,"/fw/f.html")==0){
	    if(checkHEADERParms(r, NULL, 0)==ILLEGAL){
			// TODO
			return DONE;
		}
	    return OK;
	}
	
    return OK;
}

static void pwd_waf_register_hooks(apr_pool_t *p)
{
    ap_hook_post_read_request(pwd_waf_handler, NULL, NULL, APR_HOOK_FIRST);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA pwd_waf_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    pwd_waf_register_hooks  /* register hooks                      */
};

KVPair *readPostParms(request_rec *r) {
    apr_array_header_t *pairs = NULL;
    apr_off_t len;
    apr_size_t size;
    int res;
    int i = 0;
    char *buffer;
    KVPair *kvp;
    char * record;
    
    res = ap_parse_form_data(r, NULL, &pairs, -1, HUGE_STRING_LEN);
    if (res != OK || !pairs) return NULL; /* Return NULL if we failed or if there are is no POST data */
    kvp = apr_pcalloc(r->pool, sizeof(KVPair) * (pairs->nelts + 1));
    
    while (pairs && !apr_is_empty_array(pairs)) {
        ap_form_pair_t *pair = (ap_form_pair_t *) apr_array_pop(pairs);
        apr_brigade_length(pair->value, 1, &len);
        size = (apr_size_t) len;
        buffer = apr_palloc(r->pool, size + 1);
        apr_brigade_flatten(pair->value, buffer, &size);
        buffer[len] = 0;
        kvp[i].key = apr_pstrdup(r->pool, pair->name);
        kvp[i].value = buffer;
        i++;
	}
    apr_bucket_brigade *new_brigade = apr_brigade_create(r->pool, r->connection->bucket_alloc);
	apr_bucket *bucket = apr_bucket_transient_create(record,
		strlen(record), r->connection->bucket_alloc);
	APR_BRIGADE_INSERT_TAIL(new_brigade, bucket);    
	r->kept_body = new_brigade;
    return kvp;
}

int checkGETParms(request_rec *r, Signiture * getSigList, int listSize){
	apr_table_t *GET;	
	ap_args_to_table(r, &GET);
	
	const apr_array_header_t *parmsArray = apr_table_elts(GET);
	const apr_table_entry_t * getParms = (apr_table_entry_t*)parmsArray->elts;
	
	int i = 0;
	for (i = 0; i < parmsArray->nelts; i++) {
		ap_rprintf(r,"   \n key = %s, val = %s\n", getParms[i].key, getParms[i].val);
		if(!isLegal(getParms[i].key, getParms[i].val, getSigList, listSize)){
			return ILLEGAL;
		}
	}
	return LEGAL;
}

int checkPOSTParms(request_rec *r, Signiture * postSigList, int listSize){
	KVPair *postParms;
	postParms = readPostParms(r);
    if (postParms != NULL) {
        int i = 0;
        for (i = 0; &postParms[i]; i++) {
            if (postParms[i].key && postParms[i].value) {
                ap_rprintf(r, "%s = %s\n", postParms[i].key, postParms[i].value);
                if(!isLegal(postParms[i].key, postParms[i].value, postSigList, listSize)){
					return ILLEGAL;
				}
            } 
        }
    }
    return LEGAL;
}

int checkHEADERParms(request_rec *r, Signiture * headerSigList, int listSize){
	const apr_array_header_t *header;
    apr_table_entry_t* headerParms;

    header = apr_table_elts(r->headers_in);
    headerParms = (apr_table_entry_t *) header->elts;
    int i = 0;
    for(i = 0; i < header->nelts; i++) {
        ap_rprintf(r, "%s: %s\n", headerParms[i].key, headerParms[i].val);
        if(!isLegal(headerParms[i].key, headerParms[i].val, headerSigList, listSize)){
				return ILLEGAL;
		}
    }
    return LEGAL;
}

// Returun 0 if illegal, return 1 is legal
int isLegal(const char* key, const char* value, Signiture * list, int listSize){
	int i = 0;
	for(i = 0; i < listSize; i++){
		if(strcmp(list[i].key,"*")==0 || strcmp(list[i].key, key)==0){
			if(strstr(value, list[i].value)!= NULL){
				return 0;
			}
		}
	}
	return 1;
}


