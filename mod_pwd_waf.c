/* 
**  mod_pwd_waf.c -- Apache sample pwd_waf module
**  [Autogenerated via ``apxs -n pwd_waf -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_pwd_waf.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /pwd_waf in as follows:
**
**    #   apache2.conf
**    LoadModule pwd_waf_module modules/mod_pwd_waf.so
**    <Location /pwd_waf>
**    SetHandler pwd_waf
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /pwd_waf and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/pwd_waf 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_pwd_waf.c
*/ 

#include "mod_pwd_waf.h"

/* Web Application Firewall by Team Password */
static int pwd_waf_handler(request_rec *r)
{
	// parse Signiture file and read all configuration into memory
    // parseConfigFile();

    /* check GET method parameters*/
    if(getNum > 0)	{
      	// Get
      	if(checkGETParms(r, getList, getNum)==ILLEGAL){
			showIllegalStr(r);
			return DONE;
		}
	}
	/* check POST method parameters */
	if(postNum > 0){
		if(checkPOSTParms(r, postList, postNum)==ILLEGAL){
			showIllegalStr(r);
			return DONE;
		}
	}
	
	/* check header parameters*/
	if(headerNum > 0){
	    if(checkHEADERParms(r, headerList, headerNum)==ILLEGAL){
			showIllegalStr(r);
			return DONE;
		}
	}

	// Anomaly Detection
	if(MODE == TRAINMODE){
		// TODO
		ap_rprintf(r,"This is Train Mode....");
		
	}else if (MODE == GENERATEPROFILE){
		// Generate Profile
	}else{
	
		// Detection MODE
	}
	
    return OK;
}

static void pwd_waf_register_hooks(apr_pool_t *p)
{
    ap_hook_post_read_request(pwd_waf_handler, NULL, NULL, APR_HOOK_FIRST);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA pwd_waf_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    pwd_waf_register_hooks  /* register hooks                      */
};

KVPair *readPostParms(request_rec *r) {
	/*apr_table_t *t;
	if (ap_body_to_table(r, &t) == APR_SUCCESS) {
		const apr_array_header_t *parmsArray = apr_table_elts(t);
		const apr_table_entry_t * getParms = (apr_table_entry_t*)parmsArray->elts;
	
		int i = 0;
		for (i = 0; i < parmsArray->nelts; i++) {
			ap_rprintf(r,"   \n key = %s, val = %s\n", getParms[i].key, getParms[i].val);
		}
	}
	return NULL;*/
    apr_array_header_t *pairs = NULL;
    apr_off_t len;
    apr_size_t size;
    int res;
    int i = 0;
    char *buffer;
    KVPair *kvp = NULL;
    
    apr_table_t *t;	
	ap_args_to_table(r, &t);

    res = ap_parse_form_data(r, NULL, &pairs, -1, HUGE_STRING_LEN);
    if (res != OK || !pairs) return NULL; 
    kvp = apr_pcalloc(r->pool, sizeof(KVPair) * (pairs->nelts + 1));
    while (pairs && !apr_is_empty_array(pairs)) {
        ap_form_pair_t *pair = (ap_form_pair_t *) apr_array_pop(pairs);
        apr_brigade_length(pair->value, 1, &len);
        size = (apr_size_t) len;
        buffer = apr_palloc(r->pool, size + 1);
        apr_brigade_flatten(pair->value, buffer, &size);
        buffer[len] = 0;
        kvp[i].key = apr_pstrdup(r->pool, pair->name);
        kvp[i].value = buffer;
        apr_table_set(t, kvp[i].key, kvp[i].value);
        i++;
    }
    return kvp;
}

int checkGETParms(request_rec *r, Signiture * getSigList, int listSize){
	apr_table_t *GET;	
	ap_args_to_table(r, &GET);
	
	const apr_array_header_t *parmsArray = apr_table_elts(GET);
	const apr_table_entry_t * getParms = (apr_table_entry_t*)parmsArray->elts;
	
	int i = 0;
	for (i = 0; i < parmsArray->nelts; i++) {
		ap_rprintf(r,"   \n key = %s, val = %s\n", getParms[i].key, getParms[i].val);
		if(!isLegal(getParms[i].key, getParms[i].val, getSigList, listSize)){
			return ILLEGAL;
		}
	}
	return LEGAL;
}

int checkPOSTParms(request_rec *r, Signiture * postSigList, int listSize){
	KVPair *postParms = NULL;
	postParms = readPostParms(r);
    if (postParms != NULL) {
        int i = 0;
        for (i = 0; &postParms[i]; i++) {
            if (postParms[i].key && postParms[i].value) {
                ap_rprintf(r, "%s = %s\n", postParms[i].key, postParms[i].value);
                if(!isLegal(postParms[i].key, postParms[i].value, postSigList, listSize)){
					return ILLEGAL;
				}
            }else{
				break;
			} 
        }
    }
    return LEGAL;
}

int checkHEADERParms(request_rec *r, Signiture * headerSigList, int listSize){
	const apr_array_header_t *header;
    apr_table_entry_t* headerParms;

    header = apr_table_elts(r->headers_in);
    headerParms = (apr_table_entry_t *) header->elts;
    int i = 0;
    for(i = 0; i < header->nelts; i++) {
        //ap_rprintf(r, "%s: %s\n", headerParms[i].key, headerParms[i].val);
        if(!isLegal(headerParms[i].key, headerParms[i].val, headerSigList, listSize)){
				return ILLEGAL;
		}
    }
    return LEGAL;
}

// Returun 0 if illegal, return 1 is legal
int isLegal(const char* key, const char* value, Signiture * list, int listSize){
	int i = 0;
	for(i = 0; i < listSize; i++){
		if(strcmp(list[i].key,"*")==0 || strcmp(list[i].key, key)==0){
			if(strstr(value, list[i].value)!= NULL){
				if(illegalStr == NULL){
					illegalStr = (char *) calloc(0, SIGNITURE_BUFFER_SIZE);
				}
				strcpy(illegalStr, list[i].value);
				return 0;
			}
		}
	}
	return 1;
}

void showIllegalStr(request_rec *r){
	ap_set_content_type(r, "text/html");
	ap_rprintf(r,"<H2>Request is blocked by WAF, the request contains malicious string:<H2> <H1>%s.<H1>\n", illegalStr); 
}

