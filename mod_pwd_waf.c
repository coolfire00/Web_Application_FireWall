/* 
**  mod_pwd_waf.c -- Apache sample pwd_waf module
**  [Autogenerated via ``apxs -n pwd_waf -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_pwd_waf.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /pwd_waf in as follows:
**
**    #   apache2.conf
**    LoadModule pwd_waf_module modules/mod_pwd_waf.so
**    <Location /pwd_waf>
**    SetHandler pwd_waf
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /pwd_waf and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/pwd_waf 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_pwd_waf.c
*/ 

#include "mod_pwd_waf.h"

/* Web Application Firewall by Team Password */
static int pwd_waf_handler(request_rec *r)
{
	// Get current mode
	MODE = readCurrentMode();

	// check if is change mode request
	if(isChangeMode(r->uri)){
		if(isAdmin(r)){
			apr_table_t *t;	
			ap_args_to_table(r, &t);
			const char *mode;
			mode = apr_table_get(t, "mode");
			if(strcmp(mode, "Train")==0){
				MODE = TRAINMODE;
			}else if(strcmp(mode, "Generate_Profile")==0){
				MODE = GENERATEPROFILE;
			}else{
				MODE = DETECTIONMODE;
			}
		}else{
			ap_set_content_type(r, "text/html");
			ap_rprintf(r,"<H2>Username or Password is not correct!</H2>");
			return DONE;
		}
	}
	// parse Signiture file and read all configuration into memory
    parseConfigFile();

    /* check GET method parameters*/
    if(getNum > 0)	{
      	// Get
      	if(checkGETParms(r, getList, getNum)==ILLEGAL){
			showIllegalStr(r);
			return DONE;
		}
	}
	/* check POST method parameters */
	if(postNum > 0){
		if(checkPOSTParms(r, postList, postNum)==ILLEGAL){
			showIllegalStr(r);
			return DONE;
		}
	}
	
	/* check header parameters*/
	if(headerNum > 0){
	    if(checkHEADERParms(r, headerList, headerNum)==ILLEGAL){
			showIllegalStr(r);
			return DONE;
		}
	}
	// Update Mode to file
	
	connect_mysql();
	// Anomaly Detection
	if(MODE == TRAINMODE){
		// Do trainning
		//ap_rprintf(r,"This is Train Mode....");
		saveRequestInfo(r);
		writeCurrentMode(MODE);
	}else if (MODE == GENERATEPROFILE){
		//ap_rprintf(r, "Generate Profile");
		// Generate Profile
		generateProfile();
		//Then change mode to detection
		MODE = DETECTIONMODE;
		writeCurrentMode(MODE);
	}else{
		// Detection MODE
		//ap_rprintf(r,"This is Detection Mode....");
		int result = PASSDETECTION;
		result = detectRequest(r);
		mysql_close(conn);
		writeCurrentMode(MODE);
		if(result == EXCEEDMAXPARAMNUM){
			// exceed max parameter number
			char * errorInfo= "The parameter number exceeded max number!";
			showDetectionResult(r, errorInfo);
			return DONE;
		}else if(result == PARAMLENILLEGAL){
			// parameters length is illegal
			char * errorInfo= "Some parameters' length are illegal!";
			showDetectionResult(r, errorInfo);
			return DONE;
		}else if(result == CONTAINSNOSEENCHAR){
			// Contains no seen characters
			char * errorInfo= "Some parameters contain illegal characters!";
			showDetectionResult(r, errorInfo);
			return DONE;
		}else if(result == UNKNOWNPRARM){
			// Contains unknown parameter
			char * errorInfo= "Some parameters are unknwn!";
			showDetectionResult(r, errorInfo);
			return DONE;
		}else if(result == EXCEEDALLMAXNUM){
			// The page is unknown, and its parameter num exceed all pages' parametes number
			char * errorInfo = "The parameter number exceeds max number of all pages!";
			showDetectionResult(r, errorInfo);
			return DONE;
		}else{
			// Pass detection
			return OK;
		}
	}
	
	mysql_close(conn);	
	
	// The request need response
	if(isChangeMode(r->uri)){
		showModeChangeInfo(r, MODE);
		return DONE;
	}
	
    return OK;
}

static void pwd_waf_register_hooks(apr_pool_t *p)
{
    ap_hook_post_read_request(pwd_waf_handler, NULL, NULL, APR_HOOK_FIRST);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA pwd_waf_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    NULL,                  /* table of config file commands       */
    pwd_waf_register_hooks  /* register hooks                      */
};

KVPair *readPostParms(request_rec *r) {
    apr_array_header_t *pairs = NULL;
    apr_off_t len;
    apr_size_t size;
    int res;
    int i = 0;
    char *buffer;
    KVPair *kvp = NULL;
    
    apr_table_t *t;	
	ap_args_to_table(r, &t);

    res = ap_parse_form_data(r, NULL, &pairs, -1, HUGE_STRING_LEN);
    if (res != OK || !pairs) return NULL; 
    kvp = apr_pcalloc(r->pool, sizeof(KVPair) * (pairs->nelts + 1));
    while (pairs && !apr_is_empty_array(pairs)) {
        ap_form_pair_t *pair = (ap_form_pair_t *) apr_array_pop(pairs);
        apr_brigade_length(pair->value, 1, &len);
        size = (apr_size_t) len;
        buffer = apr_palloc(r->pool, size + 1);
        apr_brigade_flatten(pair->value, buffer, &size);
        buffer[len] = 0;
        kvp[i].key = apr_pstrdup(r->pool, pair->name);
        kvp[i].value = buffer;
        apr_table_set(t, kvp[i].key, kvp[i].value);
        i++;
    }
    return kvp;
}

int checkGETParms(request_rec *r, Signiture * getSigList, int listSize){
	apr_table_t *GET;	
	ap_args_to_table(r, &GET);
	
	const apr_array_header_t *parmsArray = apr_table_elts(GET);
	const apr_table_entry_t * getParms = (apr_table_entry_t*)parmsArray->elts;
	
	int i = 0;
	for (i = 0; i < parmsArray->nelts; i++) {
		//ap_rprintf(r,"   \n key = %s, val = %s\n", getParms[i].key, getParms[i].val);
		if(!isLegal(r, getParms[i].key, getParms[i].val, getSigList, listSize)){
			return ILLEGAL;
		}
	}
	return LEGAL;
}

int checkPOSTParms(request_rec *r, Signiture * postSigList, int listSize){
	KVPair *postParms = NULL;
	postParms = readPostParms(r);
    if (postParms != NULL) {
        int i = 0;
        for (i = 0; &postParms[i]; i++) {
            if (postParms[i].key && postParms[i].value) {
                //ap_rprintf(r, "%s = %s\n", postParms[i].key, postParms[i].value);
                if(!isLegal(r, postParms[i].key, postParms[i].value, postSigList, listSize)){
					return ILLEGAL;
				}
            }else{
				break;
			} 
        }
    }
    return LEGAL;
}

int checkHEADERParms(request_rec *r, Signiture * headerSigList, int listSize){
	const apr_array_header_t *header;
    apr_table_entry_t* headerParms;

    header = apr_table_elts(r->headers_in);
    headerParms = (apr_table_entry_t *) header->elts;
    int i = 0;
    for(i = 0; i < header->nelts; i++) {
        //ap_rprintf(r, "%s: %s\n", headerParms[i].key, headerParms[i].val);
        if(!isLegal(r, headerParms[i].key, headerParms[i].val, headerSigList, listSize)){
				return ILLEGAL;
		}
    }
    return LEGAL;
}

// Returun 0 if illegal, return 1 is legal
int isLegal(request_rec *r, const char* key, const char* value, Signiture * list, int listSize){
	int i = 0;
	for(i = 0; i < listSize; i++){
		if(strcmp(list[i].key,"*")==0 || strcmp(list[i].key, key)==0){
			char * lowercaseValue =  apr_pstrdup(r->pool, value);
			toLowerCase(lowercaseValue);
			//ap_rprintf(r,"low--%s--\n", lowercaseValue);
			if(strstr(lowercaseValue,list[i].value)!= NULL){
				if(illegalStr == NULL){
					illegalStr = (char *) calloc(0, SIGNITURE_BUFFER_SIZE);
				}
				strcpy(illegalStr, list[i].value);
				return 0;
			}
		}
	}
	return 1;
}

void showIllegalStr(request_rec *r){
	ap_set_content_type(r, "text/html");
	ap_rprintf(r,"<H2>Request is blocked by WAF, the request contains malicious string:<H2> <H1>%s.<H1>\n", illegalStr); 
}

int isChangeMode(const char* uri){
	if(strcmp(uri, changeModeURI)==0){
		return 1;
	}
	return 0;
}

int isAdmin(request_rec *r){
	apr_table_t *t;	
	ap_args_to_table(r, &t);
	const char *usrInReq;
	const char *pwdInReq;
	usrInReq = apr_pcalloc(r->pool, SIGNITURE_BUFFER_SIZE);
	usrInReq = apr_table_get(t, "username");
	pwdInReq = apr_pcalloc(r->pool, SIGNITURE_BUFFER_SIZE);
	pwdInReq = apr_table_get(t, "password");
	
	//ap_rprintf(r, "usr %s: pwd %s\n", usrInReq, pwdInReq);
	char * usrInFile;
	char * pwdInFile;
	usrInFile = apr_pcalloc(r->pool, SIGNITURE_BUFFER_SIZE);
	pwdInFile = apr_pcalloc(r->pool, SIGNITURE_BUFFER_SIZE);
	read_admin_file(usrInFile, pwdInFile);
	//ap_rprintf(r, "usr %s: pwd %s\n", usrInFile, pwdInFile);
	if(strcmp(usrInReq, usrInFile)==0 && strcmp(pwdInReq, pwdInFile)==0){
		return 1;
	}
	return 0;
}

void read_admin_file(char *user, char *password){
	FILE * fp;
	fp = fopen(ADMIN_CONFIG, "r");

	char *line = (char *)malloc(SIGNITURE_BUFFER_SIZE);
	if(fp) {
		char *i, *buf;
		if (fgets(line,SIGNITURE_BUFFER_SIZE, fp) != NULL){ 
			strtok(line, "\n");
			i=strstr(line,"=");
			buf=i+1;
			strcpy(user, buf);
			
		}
		if (fgets(line,SIGNITURE_BUFFER_SIZE, fp) != NULL){ 
			strtok(line, "\n");
			i=strstr(line,"=");
			buf=i+1;
			strcpy(password, buf);
			
		}
		
		fclose(fp);           
	}
	if (line){
		free(line);
	}
}

void showModeChangeInfo(request_rec *r, int mode){
	if(mode == TRAINMODE){
		ap_set_content_type(r, "text/html");
		ap_rprintf(r,"<H2>Now the WAF is Training mode, you can start training!</H2>");
	}else if(mode == DETECTIONMODE){
		ap_set_content_type(r, "text/html");
		ap_rprintf(r,"<H2>The profile has been generated successfully, the WAF starts detecting!</H2>");
	}
}

void showDetectionResult(request_rec *r, char * result){
	ap_set_content_type(r, "text/html");
	ap_rprintf(r,"<H2>%s</H2>", result);
}

int readCurrentMode(){
	FILE * fp;
	fp = fopen(MODE_CONFIG_PATH, "r");

	char *line = (char *)malloc(SIGNITURE_BUFFER_SIZE);
	char *mode = (char *)malloc(SIGNITURE_BUFFER_SIZE);
	if(fp) {
		char *i, *buf;
		if (fgets(line,SIGNITURE_BUFFER_SIZE, fp) != NULL){ 
			strtok(line, "\n");
			i=strstr(line,"=");
			buf=i+1;
			strcpy(mode, buf);	
		}
		fclose(fp);           
	}
	if (line){
		free(line);
	}
	int modeCode = 0;
	if(strcmp(mode, "Train")==0){
		modeCode = TRAINMODE;
	}else{
		modeCode = DETECTIONMODE;
	}
	return modeCode;
}

void writeCurrentMode(int modeCode){
	char * mode;
	if(modeCode == TRAINMODE){
		mode = "Train";
	}else{
		mode = "Detection";
	}
	FILE *f = fopen(MODE_CONFIG_PATH, "w");
	if (f == NULL){
		exit(1);
	}
	char *str=(char *)malloc(WRITE_BUFFER_SIZE);
	str[0] = '\0'; 
	strcat(str, "Mode=");
	strcat(str,mode);
	fprintf(f, "%s", str);
	fclose(f);
}

void toLowerCase(char * str){
    int len = strlen(str);
    int i = 0;
    for(i=0; i<len; i++){
        str[i] = tolower(str[i]);
    }
}
